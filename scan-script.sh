#!/bin/bash

# Dynamically determine the script's current directory.
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

# Configuration
EXPORTER_DATA_DIR="${SCRIPT_DIR}/exporter/data" # Dynamically set path
SCAN_INTERVAL=1800 # 30 minutes
DOCKER_COMPOSE_FILE="${SCRIPT_DIR}/docker-compose.yml" # Ensure the path is dynamically set

# ANSI color codes for printing messages in color
RED="\033[1;31m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
RESET="\033[0m"

# Ensure required directories exist
mkdir -p "${EXPORTER_DATA_DIR}"

# Function to print messages with color
print_color() {
    echo -e "${!1}${2}${RESET}"
}

# Function to scan Docker images
scan_docker_images() {
    print_color YELLOW "Scanning Docker images..."
    docker images --format '{{.Repository}}:{{.Tag}}' | while read -r image; do
        if [[ $image != *"<none>:<none>"* ]]; then
            local timestamp=$(date +"%Y-%m-%d-%I-%M-%S-%p")
            local result_file="${EXPORTER_DATA_DIR}/docker-scan-${timestamp}.json"
            grype $image -o json > "$result_file"
            print_color GREEN "Saved Docker scan result to ${result_file}"
        fi
    done
}

# Function to scan Kubernetes pods
scan_kubernetes_pods() {
    print_color YELLOW "Scanning Kubernetes pods..."
    kubectl get pods --all-namespaces -o jsonpath="{.items[*].spec.containers[*].image}" | tr -s '[[:space:]]' '\n' | sort | uniq | while read -r image; do
        if [[ $image != *"<none>:<none>"* ]]; then
            local timestamp=$(date +"%Y-%m-%d-%I-%M-%S-%p")
            local result_file="${EXPORTER_DATA_DIR}/k8s-scan-${timestamp}.json"
            grype $image -o json > "$result_file"
            print_color GREEN "Saved Kubernetes scan result to ${result_file}"
        fi
    done
}

# Function to start Docker Compose in detached mode
start_docker_compose() {
    print_color YELLOW "Starting Docker Compose in detached mode..."
    docker-compose -f "$DOCKER_COMPOSE_FILE" up -d
    print_color GREEN "Docker Compose has been started."
}

# Function for handling Ctrl-C (SIGINT)
handle_sigint() {
    print_color RED "\nDetected Ctrl-C. Gracefully terminating..."
    exit
}

# Trap SIGINT (Ctrl-C) and execute handle_sigint function
trap handle_sigint SIGINT

# Main scanning function with start/end time logging
perform_scan() {
    local start_time=$(date +"%I:%M:%S %p")
    print_color YELLOW "Scan started at: $start_time"
    scan_docker_images
    scan_kubernetes_pods
    local end_time=$(date +"%I:%M:%S %p")
    print_color YELLOW "Scan completed at: $end_time"
}

# User prompt for scan mode selection
echo "Choose the scan mode:"
echo "1) One-time scan"
echo "2) Run like a cron job"
read -rp "Enter your choice (1/2): " user_choice

case $user_choice in
    1)
        perform_scan
        start_docker_compose
        ;;
    2)
        while true; do
            perform_scan
            print_color YELLOW "Next scan scheduled after 30 minutes."
            sleep "$SCAN_INTERVAL"
        done
        ;;
    *)
        print_color RED "Invalid choice. Exiting."
        exit 1
        ;;
esac

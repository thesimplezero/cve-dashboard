package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

// CVEData represents the expected structure of CVE data in JSON files.
type CVEData struct {
	Matches []CVEItem `json:"matches"`
}

// CVEItem represents the nested structure of the CVE data.
type CVEItem struct {
	Vulnerability struct {
		ID       string `json:"id"`
		Severity string `json:"severity"`
		Fix      struct {
			State string `json:"state"`
		} `json:"fix"`
	} `json:"vulnerability"`
	Artifact struct {
		Name    string `json:"name"`
		Version string `json:"version"`
	} `json:"artifact"`
}

var (
	// Prometheus metric with labels for CVE data.
	vulnMetric = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "vuln_operator_cves",
		Help: "Tracks CVE occurrences.",
	}, []string{"cve", "severity", "package", "version", "fix_state"})
)

// parseJSONData reads and parses CVE data from a JSON file.
func parseJSONData(filePath string) {
	fileContent, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Printf("Unable to read file %s: %s", filePath, err)
		return
	}

	var data CVEData
	err = json.Unmarshal(fileContent, &data)
	if err != nil {
		log.Printf("Invalid JSON in file %s: %s", filePath, err)
		return
	}

	for _, match := range data.Matches {
		vulnMetric.With(prometheus.Labels{
			"cve":       match.Vulnerability.ID,
			"severity":  match.Vulnerability.Severity,
			"package":   match.Artifact.Name,
			"version":   match.Artifact.Version,
			"fix_state": match.Vulnerability.Fix.State,
		}).Set(1)
	}
}

// processDataFiles processes all JSON files in the 'data' directory.
func processDataFiles(dataDir string) {
	files, err := ioutil.ReadDir(dataDir)
	if err != nil {
		log.Fatalf("Failed to read data directory: %s", err)
	}

	for _, f := range files {
		if strings.HasSuffix(f.Name(), ".json") {
			filePath := filepath.Join(dataDir, f.Name())
			parseJSONData(filePath)
		}
	}
}

func main() {
	// Set up logging to a file.
	logFile, err := os.OpenFile("exporter.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Error opening log file: %s", err)
	}
	defer logFile.Close()
	log.SetOutput(logFile)

	// Schedule the data processing job to run every 20 seconds.
	dataDir := "./data"
	processDataFiles(dataDir) // Process once on startup.
	ticker := time.NewTicker(20 * time.Second)
	go func() {
		for range ticker.C {
			processDataFiles(dataDir)
		}
	}()
	defer ticker.Stop()

	// HTTP handler for Prometheus metrics, with logging.
	http.Handle("/metrics", loggingHandler(promhttp.Handler()))

	// Start server on :9092 and listen for requests.
	log.Println("Server listening on :9092")
	if err := http.ListenAndServe(":9092", nil); err != nil {
		log.Fatalf("Failed to start server: %s", err)
	}
}

// loggingHandler is a middleware that logs HTTP requests.
func loggingHandler(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Printf("Received request: Method=%s Path=%s RemoteAddr=%s", r.Method, r.URL.Path, r.RemoteAddr)
		next.ServeHTTP(w, r)
	})
}
